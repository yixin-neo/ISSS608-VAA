---
title: "Hands-on Exercise 14 (Week 7: Visualising and Analysing Time-oriented Data)"
author: "NYX"
date: '3 June 2023'
date-modified: "`r Sys.Date()`"
editor: visual
execute: 
  freeze: auto
  warning: false
  #echo: false
  #message: false
format:
  html:
    code-fold: True
    code-overflow: scroll
    code-summary: "Show the code"
    code-line-numbers: true
---

## **17.1 Learning Outcome**

-   plotting a calender heatmap by using ggplot2 functions,

-   plotting a cycle plot by using ggplot2 function,

-   plotting a slopegraph

-   plotting a horizon chart

## **17.2 Getting Started**

## **17.3 Do It Yourself**

Write a code chunk to check, install and launch the following R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.

```{r}
pacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)
```

## **17.4 Plotting Calendar Heatmap**

In this section, you will learn how to plot a calender heatmap programmetically by using ggplot2 package.

Objectives for this section:

-   plot a calender heatmap by using ggplot2 functions and extension,

-   to write function using R programming,

-   to derive specific date and time related field by using base R and lubridate packages

-   to perform data preparation task by using tidyr and dplyr packages.

### **17.4.1 The Data**

For the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.

### **17.4.2 Importing the data**

First, you will use the code chunk below to import *eventlog.csv* file into R environment and called the data frame as *attacks*.

```{r}
attacks <- read_csv("data/eventlog.csv")
```

### **17.4.3 Examining the data structure**

It is always a good practice to examine the imported data frame before further analysis is performed.

For example, *kable()* can be used to review the structure of the imported data frame.

```{r}
kable(head(attacks))
```

There are three columns, namely *timestamp*, *source_country* and *tz*.

-   *timestamp* field stores date-time values in POSIXct format.

-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.

-   *tz* field stores time zone of the source IP address.

### **17.4.4 Data Preparation**

Step 1: Deriving *weekday* and *hour of day* fields

Before we can plot the calender heatmap, two new fields namely *wkday* and *hour* need to be derived. In this step, we will write a function to perform the task.

```{r}
make_hr_wkday <- function (ts, sc, tz) {
  real_times <- ymd_hms(ts,
                        tz = tz[1],     #<< for group by tz later, simply use the first tz value of groupby
                        quiet = TRUE)
  
  dt <- data.table(source_country = sc,
                   wkday= weekdays(real_times),
                   hour = hour(real_times))
  return (dt)
}
```

::: callout-note
-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and

-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.
:::

```{r}
wkday_levels <- c('Saturday', 'Friday', 
                  'Thursday', 'Wednesday', 
                  'Tuesday', 'Monday', 
                  'Sunday')

attacks <- attacks %>%
  group_by(tz) %>%
  do(make_hr_wkday(.$timestamp, 
                   .$source_country, 
                   .$tz)) %>% 
  ungroup() %>% 
  mutate(wkday = factor(wkday, levels = wkday_levels),
         hour = factor(hour, levels = 0:23))  #<< 24 hrs 
```

Explanation of the code chunk above

1.  **`tz`** refers to the **`tz`** column of the **`attacks`** dataframe.

2.  **`tz[1]`** selects the first element of the **`tz`** column within each group.

3.  The **`group_by(tz)`** statement groups the data based on unique values in the **`tz`** column.

4.  The **`do()`** function is used to apply the **`make_hr_wkday`** function to each group of the grouped dataframe.

5.  Within the **`make_hr_wkday`** function, **`tz[1]`** is used to specify the time zone for the conversion of the timestamps within each group. Since each group has the same time zone value, using **`tz[1]`** ensures that the function uses the correct time zone for each group.

By grouping the **`attacks`** dataframe by the **`tz`** column and applying the **`make_hr_wkday`** function within each group, the resulting dataframe will contain the source country, weekday, and hour columns based on the timestamp, source country, and time zone information, grouped by the unique time zones in the **`tz`** column of the **`attacks`** dataframe.

::: callout-note
Beside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they'll be ordered when plotting
:::

Table below shows the tidy tibble table after processing.

```{r}
kable(head(attacks))
```
